1、在mounted函数中执行compileToFunctions函数,并将用户的自定义的参数传入，主要是为了
  将模板字符串编译成render函数和staticRenderFns函数。

2、那compileToFunctions函数怎么来的呢？
   createCompilerCreator函数执行创建了createCompiler函数 ------>
   然后执行了createCompiler函数,在createCompiler函数中又执行了createCompileToFunctionFn函数,
   createCompileToFunctionFn函数执行创建了compileToFunctions函数,
   最后等于createCompiler函数创建了compile函数和compileToFunctions函数

3、compileToFunctions函数干了什么?
   1、获取参数中的warn函数
   2、判断vue是否执行在一个禁止不安全eval的环境中
   3、将模板字符串和用户自定义的文本表达式符号拼接作为对象key,
      用于缓存render函数和staticRenderFns数组的，因为在模板字符串不变的情况下不需要
      重新解析编译。
   4、执行compile函数生成render字符串和staticRenderFns数组。
   5、执行createFunction函数将编译好的表达式字符串生成render函数。
   6、循环执行createFunction函数将staticRenderFns数组中的编译好的表达式字符串生成render函数，并返回保存这些render函数的staticRenderFns数组
   7、将编译时的错误信息提示出来
   8、将render函数和staticRenderFns数组输出
   总结: compileToFunctions函数主要是将compile函数生成的render字符串变成函数并将解析过程中的
        警告和错误提示出来。

4、compile函数是怎么生成render字符串和staticRenderFns数组的？
   1、初始化了errors数组和tips数组，生成一个根据传入的参数判断往errors数组或tips数组中添加信息
   2、合并用户自定义的modules、directives和默认的modules、directives
   3、用户自定义的一些参数替换默认的参数
   4、执行baseCompile函数生成render字符串和staticRenderFns数组,以及收集错误和提示信息
   5、收集AST树中的错误信息
   6、将errors数组和tips数组和ast树和render字符串和staticRenderFns数组作为对象对应的属性值输出
   总结: compile函数中生成的render字符串和staticRenderFns数组是由baseCompile函数生成的,
        compile函数只是合并了一些参数和初始化了错误、提示收集框

5、baseCompile函数是怎么生成render字符串和staticRenderFns数组的？
   1、执行了parse函数将字符串模板解析成抽象语法树(AST)
   2、根据用户在未明确传递了optimize参数为false时,对ast树进行优化
   3、执行generate函数将ast树编译成渲染函数字符串
   4、将ast树和渲染函数字符串和staticRenderFns数组输出
   总结: baseCompile函数主要是将parse函数和generate函数生成的东西输出

6、parse函数是怎么生成ast树的？
   1、缓存一系列option中的参数(比如compile函数中生成的通过参数判断往errors数组或tips数组中添加信息的warn函数)
   2、初始化保存节点起始标签的stack、是否保存空格的变量、根节点信息root、缓存当前节点的currentParent、判断文本标签的
      inVPre和inPre变量、控制只提示一次错误或警告信息的warned变量
   3、初始化只收集一次错误信息的warnOnce函数、将inVPre和inPre变量初始化的函数
   4、执行parseHTML函数解析模板字符串
   5、将root信息输出

  一、parseHTML函数是怎么解析模板字符串的(模板字符串用html代替,</div>代表闭合标签,>代表结束标签)
      1、初始化保存起始标签名的数组stack、字符下标index、用于缓存模板的last、缓存模板当前标签的lastTag
          缓存一系列option参数、一系列用以解析标签的函数
      2、进入一个通过判断html是否被解析完的循环中,首先是将html缓存到last变量中,然后进入一个判断            ↓
          -----当lastTag不存在(也就是保存任何标签名)时 || lastTag标签名不为文本标签(script,style,textarea)时
                这个时候会去查找html中的第一个<字符,接下来会出现种情况:
                    1、html的第一个字符就是<,但是第一个是<并不代表就一定是标签的<,也有可能是注释的<等等，所以这里又会有好几种情况，并对其一一处理
                        1、第一种: 为注释节点。
                            - 获取-->的下标,当用户需要保存注释时,将注释保存在当前父元素对象的children
                              数组里,最后将index下标更新,将html中的注释剔除

                        2、第二种: 条件注释节点 比如: <!--[if !IE]>-->
                            - 获取]>的下标,直接将index下标更新,将html中的条件注释剔除

                        3、第三种: doctype节点
                            - 获取doctype节点,接将index下标更新,将html中的doctype节点剔除

                        4、第四种: 闭合标签
                            - 获取比如:</div 字符,缓存index下标,将index下标更新,将html中的</div字符剔除,
                              获取当前闭合标签名在保存起始标签的stack数组中的下标为变量pos.

                            - 那么这个pos一定对应的是stack数组的最后一个,因为最后的开始标签一定是先闭合的
                              比如: <div><span></span></div> 中,span是最后的开始标签那么它一定是先闭合的,
                              所以如果不是最后一个则说明stack数组中缓存的标签中存在没有闭合的标签,这时会警告
                              标签没有闭合,并将当前标签和那些没有闭合的标签进行闭合

                            - 怎么进行闭合？

                        5、第五种: 起始标签
                            - 获取起始标签,将index下标更新,将html中的起始标签剔除,然后进入一个循环.
                              前提是 当标签名后面跟的不是>字符 && 标签上写有属性时,简单可以理解为当前标签
                              有设置属性时, 将index下标更新为该字符在html中的位置,然后将该属性从html中剔除,
                              最后是将属性字符串保存在match对象的attrs数组中。依次循环，直到属性字符串全部保存在
                              match对象的attrs数组中。-------总的来说该循环就是用来保存属性字符串的

                              比如:  class="item" :item="item"></div>这个字符串,满足条件,获取class="item"
                              在整个字符串中的位置,并将位置下标更新给index,然后将class="item"从整个字符串中
                              剔除,最后将class="item"字符串保存在match对象的attrs数组中,直到:item="item"也
                              保存进match对象的attrs数组中后退出循环

                            - 当存在>或/>字符时,表示当前起始标签处理结束,设置match.unarySlash为'/'或undefined(
                              这个由是否存在/字符决定的,存在表示该标签为一元标签),更新index为>或/>在html中的下标,
                              并将>或/>从html中剔除,设置match.end为index,然后将match对象输出。---------------
                              ---这个match中存储着标签字符在html中的起始位置和结束位置、标签名、所有的属性字符串,
                                 最后将match对象输出(*前提是该标签有结束标签)

                            - 当match对象存在时(也就是完整的存在一个起始标签时),
                                · 如果上一个起始标签为p标签&&当前标签为非段落式内容模型标签(比如div)时,直接将上一个起始标签P闭合。
                                  将p标签从stack数组中删除,将lastTag设置为p标签的前一个起始标签。

                                · 如果当前起始标签不是一元标签但是可以自己补全并闭合的标签&&当前起始标签名与上一个标签名相同时,
                                  将上一个起始标签闭合,并从stack数组中删除,将lastTag设置为上一个起始标签的前一个起始标签.

                              循环match中的attr數組(标签的属性),缓存属性值或空字符串,并对转义了的属性值进行转义,
                              生成一个{name: 属性名, value: 属性值}的对象放入attrs数组中。
                              当前标签不为一元标签 || 未设置/结束符时,将该标签名和属性信息生成一个对象放入stack数组中,
                              并赋值lastTag为当前标签

                            - 当前标签名为svg并在IE浏览器下把svg的属性名修改成普通浏览器下一样,然后生成一个ASTElement对象,
                              ASTElement = {
                                type: 1,                        //节点标签
                                tag,                            //标签名
                                attrsList: attrs,               //属性集合
                                attrsMap: makeAttrsMap(attrs),  //属性名:属性值格式的对象
                                parent,                         //当前节点的父元素
                                children: []                    //收集子元素信息的集合
                              }
                              当标签名为svg或math时,添加ASTElement对象的ns属性为true,当在非服务端下&&当前标签名为
                              (style或类型未设置的script或type为text/javascript的script)时,添加ASTElement对象的forbidden属性
                              为true并将错误信息添加到errors数组中。
                              当该标签为input标签&&存在v-model属性时&&type(动态属性或静态属性)不为(空或undefined)时,删除v-for属性信息,
                              并对key、ref、Slot、is、inline-template、css、style等等属性处理,并设置if、else、elseif、ifConditions属性。













































































